# dz_05
># Практические задания. 
>## "Быстрая сортировка"
>## Студент Крылов Эдуард Васильевич
>## Дата: 16.12.2025г.

># 01
>>## Анализ стека вызовов для n = 5
>>  При вызове fibonacci(5) происходит древовидная рекурсия — каждая функция вызывает две другие, пока не достигнет базовых случаев (n ≤ 1).

#### Полный порядок вызовов (с отступами для наглядности):
    fibonacci(5)
    ├── fibonacci(4)
    │   ├── fibonacci(3)
    │   │   ├── fibonacci(2)
    │   │   │   ├── fibonacci(1) → возвращает 1
    │   │   │   └── fibonacci(0) → возвращает 0
    │   │   └── fibonacci(1) → возвращает 1
    │   └── fibonacci(2)
    │       ├── fibonacci(1) → возвращает 1
    │       └── fibonacci(0) → возвращает 0
    └── fibonacci(3)
        ├── fibonacci(2)
        │   ├── fibonacci(1) → возвращает 1
        │   └── fibonacci(0) → возвращает 0
        └── fibonacci(1) → возвращает 1

>## Сложность: O(n)

># 02
>## Рекурсивнуя функция для нахождения максимального элемента в списке, используя подход "Разделяй и властвуй"

>## Как это работает (на примере [3, 7, 2, 9])
>### 1. Исходный вызов: find_max([3,7,2,9], 0, 3)
>### - mid = (0+3)//2 = 1
>### Рекурсивно вызываем:
>### - left_max = find_max([3,7,2,9], 0, 1)
>### - right_max = find_max([3,7,2,9], 2, 3)
>### 2. Левая половина [3,7]:
>### - mid = 0
>### - left_max = find_max([3,7], 0, 0) → 3
>### - right_max = find_max([3,7], 1, 1) → 7
>### - Возвращаем max(3,7) = 7
>### 3. Правая половина [2,9]:
>### - mid = 2
>### - left_max = find_max([2,9], 2, 2) → 2
>### - right_max = find_max([2,9], 3, 3) → 9
>### - Возвращаем max(2,9) = 9
>### 4. Финальный результат: max(7,9) = 9

> #### Визуализация стека вызовов:

    find_max([3,7,2,9], 0,3)
    ├── find_max([3,7,2,9], 0,1)
    │   ├── find_max([3,7,2,9], 0,0) → 3
    │   └── find_max([3,7,2,9], 1,1) → 7
    │   → max(3,7)=7
    └── find_max([3,7,2,9], 2,3)
        ├── find_max([3,7,2,9], 2,2) → 2
        └── find_max([3,7,2,9], 3,3) → 9
        → max(2,9)=9
    → max(7,9)=9

## Сложность: O(n)

># 03 
># Функция для реализации быстрой сортировки (QuickSort)
> 
>## Основной алгоритм
>## - Выбор опорного элемента (pivot) из массива.
>## - Разделение: переставляем элементы так, чтобы:
>## слева от pivot были элементы ≤ pivot,
>## справа — элементы > pivot.
>## - Рекурсивно сортируем левую и правую части.
>## Объединение не требуется — массив уже упорядочен после разделения.
> 
> 
>## QuickSort — быстрый и широко используемый алгоритм.
>## - Простая реализация, но требует внимания к выбору pivot.
>## - Подходит для больших массивов при условии хорошей реализации.