# ДЗ_05. Практические задания

**Студент:** Крылов Эдуард Васильевич  
**Дата:** 16.12.2025 г.

---

## Задание 01. Анализ стека вызовов для `n = 5`

При вызове `fibonacci(5)` происходит древовидная рекурсия: каждая функция вызывает две другие, пока не достигнет базовых случаев (`n ≤ 1`).

### Полный порядок вызовов (с отступами для наглядности)

    fibonacci(5)
    ├── fibonacci(4)
    │ ├── fibonacci(3)
    │ │ ├── fibonacci(2)
    │ │ │ ├── fibonacci(1) → возвращает 1
    │ │ │ └── fibonacci(0) → возвращает 0
    │ │ └── fibonacci(1) → возвращает 1
    │ └── fibonacci(2)
    │ ├── fibonacci(1) → возвращает 1
    │ └── fibonacci(0) → возвращает 0
    └── fibonacci(3)
    ├── fibonacci(2)
    │ ├── fibonacci(1) → возвращает 1
    │ └── fibonacci(0) → возвращает 0
    └── fibonacci(1) → возвращает 1


**Сложность:** O(n)

---

## Задание 02. Рекурсивная функция для нахождения максимального элемента в списке (подход «Разделяй и властвуй»)

### Пример работы: `[3, 7, 2, 9]`

1. **Исходный вызов:** `find_max([3,7,2,9], 0, 3)`  
   - `mid = (0 + 3) // 2 = 1`  
   - Рекурсивно вызываем:  
     - `left_max = find_max([3,7,2,9], 0, 1)`  
     - `right_max = find_max([3,7,2,9], 2, 3)`

2. **Левая половина `[3,7]`:**  
   - `mid = 0`  
   - `left_max = find_max([3,7], 0, 0) → 3`  
   - `right_max = find_max([3,7], 1, 1) → 7`  
   - Возвращаем `max(3, 7) = 7`

3. **Правая половина `[2,9]`:**  
   - `mid = 2`  
   - `left_max = find_max([2,9], 2, 2) → 2`  
   - `right_max = find_max([2,9], 3, 3) → 9`  
   - Возвращаем `max(2, 9) = 9`

4. **Финальный результат:** `max(7, 9) = 9`

### Визуализация стека вызовов

    find_max([3,7,2,9], 0,3)
    ├── find_max([3,7,2,9], 0,1)
    │ ├── find_max([3,7,2,9], 0,0) → 3
    │ └── find_max([3,7,2,9], 1,1) → 7
    │ → max(3,7)=7
    └── find_max([3,7,2,9], 2,3)
    ├── find_max([3,7,2,9], 2,2) → 2
    └── find_max([3,7,2,9], 3,3) → 9
    → max(2,9)=9
    → max(7,9)=9


**Сложность:** O(n)

---

## Задание 03. Быстрая сортировка (QuickSort)


### Основной алгоритм

1. Выбираем **опорный элемент (pivot)** из массива.  
2. **Разделяем** элементы:  
   - слева от `pivot` — элементы ≤ `pivot`;  
   - справа от `pivot` — элементы > `pivot`.  
3. Рекурсивно сортируем **левую** и **правую** части.  
4. **Объединение не требуется** — массив уже упорядочен после разделения.

### Особенности QuickSort

- Простая реализация, но требует внимания к выбору `pivot`.  
- Эффективен для больших массивов при качественной реализации.  
- Широко используется на практике.

---

## Задание 04. Сравнение алгоритмов сортировки

### Таблица сравнения (приблизительные оценки)

| Размер списка   | Quick Sort (мс) | Insertion Sort (мс) | Отношение времени |
|---------------|----------------|--------------------|-----------------|
| 10 элементов  | 0.01–0.05      | 0.02–0.06          | ≈1 (разница незначительна) |
| 100 элементов | 0.5–1.5        | 5–10               | Quick Sort в 5–20 раз быстрее |
| 1000 элементов| 10–30           | 500–1000           | Quick Sort в 20–100 раз быстрее |

### Ключевые выводы

- **Для малых списков (n ≤ 50):** сортировка вставками может быть предпочтительнее из‑за простоты и меньших накладных расходов.  
- **Для средних и больших списков:** Quick Sort значительно быстрее, особенно на случайных данных.  
- **На частично отсортированных данных:** Insertion Sort показывает хорошие результаты, превосходя Quick Sort на небольших подсписках.  
- **В реальных приложениях:** часто используют гибридные подходы (например, *Introsort*), комбинирующие Quick Sort с Insertion Sort для малых подсписков.
